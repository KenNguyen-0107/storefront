---
description:
globs:
alwaysApply: false
---
# Security Guidelines

## Authentication & Authorization

1. **JWT Handling**
   ```typescript
   // security/jwt.ts
   interface JWTConfig {
     secret: string;
     expiresIn: string;
     algorithm: 'HS256' | 'RS256';
   }

   class JWTService {
     private readonly config: JWTConfig;

     async verify(token: string): Promise<DecodedToken> {
       try {
         // Always verify exp and nbf claims
         return await verifyToken(token, this.config);
       } catch (error) {
         throw new AuthError('Invalid token');
       }
     }
   }
   ```

2. **CORS Configuration**
   ```typescript
   // security/cors.ts
   const corsConfig = {
     allowedOrigins: ['https://trusted-domain.com'],
     allowedMethods: ['GET', 'POST'],
     allowedHeaders: ['Content-Type', 'Authorization'],
     credentials: true,
     maxAge: 86400
   };
   ```

## Data Protection

1. **Input Validation**
   ```typescript
   // validation/schema.ts
   const userSchema = z.object({
     email: z.string().email(),
     password: z.string().min(8).regex(/[A-Z]/).regex(/[0-9]/),
     role: z.enum(['user', 'admin'])
   });

   function validateInput<T>(data: unknown, schema: z.Schema<T>): T {
     return schema.parse(data);
   }
   ```

2. **Data Sanitization**
   ```typescript
   // security/sanitize.ts
   function sanitizeHtml(input: string): string {
     return DOMPurify.sanitize(input, {
       ALLOWED_TAGS: ['b', 'i', 'em', 'strong'],
       ALLOWED_ATTR: []
     });
   }
   ```

## Secure Headers

```typescript
// middleware/security-headers.ts
export function setSecurityHeaders(response: Response): Response {
  const headers = new Headers(response.headers);
  headers.set('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
  headers.set('X-Content-Type-Options', 'nosniff');
  headers.set('X-Frame-Options', 'DENY');
  headers.set('X-XSS-Protection', '1; mode=block');
  headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');
  headers.set('Content-Security-Policy', buildCSP());
  return new Response(response.body, {
    status: response.status,
    headers
  });
}
```

## Error Handling

1. **Security Error Types**
   ```typescript
   // errors/security.ts
   class SecurityError extends Error {
     constructor(
       message: string,
       public readonly code: string,
       public readonly httpStatus: number = 403
     ) {
       super(message);
       this.name = 'SecurityError';
     }
   }

   class AuthenticationError extends SecurityError {
     constructor(message = 'Authentication failed') {
       super(message, 'AUTH_FAILED', 401);
     }
   }
   ```

2. **Error Response Pattern**
   ```typescript
   // errors/handler.ts
   function handleSecurityError(error: SecurityError): Response {
     // Never expose internal error details
     const publicError = {
       code: error.code,
       message: error.message
     };

     return new Response(JSON.stringify(publicError), {
       status: error.httpStatus,
       headers: { 'Content-Type': 'application/json' }
     });
   }
   ```

## Secure Storage

1. **Sensitive Data Handling**
   ```typescript
   // storage/sensitive.ts
   interface SecureStorageConfig {
     encryption: {
       algorithm: string;
       keyDerivation: string;
     };
     storage: KVNamespace;
   }

   class SecureStorage {
     async store(key: string, value: any): Promise<void> {
       const encrypted = await this.encrypt(value);
       await this.storage.put(key, encrypted, {
         expirationTtl: 3600 // 1 hour
       });
     }
   }
   ```

## Security Best Practices

1. **Password Handling**
   - Never store plain text passwords
   - Use strong hashing (Argon2, bcrypt)
   - Implement rate limiting
   - Enforce password complexity

2. **API Security**
   - Validate all inputs
   - Use HTTPS only
   - Implement rate limiting
   - Use proper authentication
   - Keep dependencies updated

3. **Session Management**
   - Use secure session storage
   - Implement proper timeout
   - Rotate session IDs
   - Clear sessions on logout

4. **Audit Logging**
   ```typescript
   // logging/audit.ts
   interface AuditLog {
     timestamp: number;
     action: string;
     userId: string;
     resource: string;
     status: 'success' | 'failure';
     metadata: Record<string, unknown>;
   }

   async function logSecurityEvent(event: AuditLog): Promise<void> {
     // Ensure sensitive data is filtered
     const sanitizedMetadata = sanitizeLogData(event.metadata);
     await auditLogger.log({
       ...event,
       metadata: sanitizedMetadata
     });
   }
   ```
