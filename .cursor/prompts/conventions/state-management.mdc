---
description:
globs:
alwaysApply: false
---
# State Management Guidelines

## Directory Structure
```
src/
├── store/
│   ├── contexts/        # React Context definitions
│   ├── hooks/          # Custom state hooks
│   └── reducers/       # State reducers
└── types/
    └── store.ts        # State type definitions
```

## Context Pattern

1. **Context Definition**
   ```typescript
   // UserContext.tsx
   interface UserContextType {
     user: User | null;
     login: (credentials: Credentials) => Promise<void>;
     logout: () => void;
   }

   export const UserContext = createContext<UserContextType>(null!);

   export function UserProvider({ children }: PropsWithChildren) {
     // Implementation
     return (
       <UserContext.Provider value={value}>
         {children}
       </UserContext.Provider>
     );
   }
   ```

2. **Custom Hook**
   ```typescript
   // useUser.ts
   export function useUser() {
     const context = useContext(UserContext);
     if (!context) {
       throw new Error('useUser must be used within UserProvider');
     }
     return context;
   }
   ```

## State Management Patterns

1. **Local Component State**
   ```typescript
   function Component() {
     // Use for component-specific state
     const [isOpen, setIsOpen] = useState(false);
     
     // Use for complex state
     const [state, dispatch] = useReducer(reducer, initialState);
   }
   ```

2. **Shared State**
   ```typescript
   // Use Context for shared state
   function App() {
     return (
       <UserProvider>
         <ThemeProvider>
           <App />
         </ThemeProvider>
       </UserProvider>
     );
   }
   ```

## Best Practices

1. **State Location**
   - Keep state as close as possible to where it's used
   - Lift state up only when necessary
   - Use context for truly global state

2. **Performance Optimization**
   - Use useMemo for expensive calculations
   - Use useCallback for function props
   - Split context by domain
   ```typescript
   // Bad: One large context
   <AppContext.Provider>
   
   // Good: Split by domain
   <UserContext.Provider>
   <ThemeContext.Provider>
   <SettingsContext.Provider>
   ```

3. **Error Handling**
   - Implement error boundaries
   - Handle async state errors
   - Provide fallback UI

4. **Type Safety**
   - Define strict types for state
   - Use discriminated unions for actions
   - Avoid any type

## Common Patterns

1. **Loading States**
   ```typescript
   interface AsyncState<T> {
     data: T | null;
     loading: boolean;
     error: Error | null;
   }

   function useAsync<T>(asyncFn: () => Promise<T>) {
     const [state, setState] = useState<AsyncState<T>>({
       data: null,
       loading: true,
       error: null
     });
     // Implementation
   }
   ```

2. **Form State**
   ```typescript
   interface FormState<T> {
     values: T;
     errors: Record<keyof T, string>;
     touched: Record<keyof T, boolean>;
   }

   function useForm<T>(initialValues: T) {
     const [state, setState] = useState<FormState<T>>({
       values: initialValues,
       errors: {} as Record<keyof T, string>,
       touched: {} as Record<keyof T, boolean>
     });
     // Implementation
   }
   ```

## Documentation Requirements

1. **Context Documentation**
   - Document provider requirements
   - List available hooks
   - Provide usage examples

2. **State Shape**
   - Document state structure
   - Explain state updates
   - Document side effects
