---
description: 
globs: 
alwaysApply: false
---
# Cloudflare Workers Patterns

## Worker Implementation Patterns

### 1. Base Worker Structure
```typescript
export default {
  async fetch(
    request: Request,
    env: Env,
    ctx: ExecutionContext
  ): Promise<Response> {
    try {
      // Worker-specific logic here
      return new Response('OK');
    } catch (error) {
      return handleError(error);
    }
  }
};
```

### 2. API Worker Pattern
```typescript
export default {
  async fetch(
    request: Request,
    env: Env,
    ctx: ExecutionContext
  ): Promise<Response> {
    try {
      const router = new Router<Env>();
      
      // Define routes with feature-based grouping
      router
        .get('/api/v1/vms', handleListVMs)
        .post('/api/v1/vms', handleCreateVM)
        .put('/api/v1/vms/:id/start', handleStartVM)
        .put('/api/v1/vms/:id/stop', handleStopVM);
      
      return router.handle(request, env, ctx);
    } catch (error) {
      return handleError(error);
    }
  }
};
```

### 3. Forwarding Worker Pattern
```typescript
export default {
  async fetch(
    request: Request,
    env: Env,
    ctx: ExecutionContext
  ): Promise<Response> {
    try {
      // Check VM status before forwarding
      const vmId = getVMIdFromRequest(request);
      await ensureVMRunning(vmId, env);
      
      // Forward request to VM
      return forwardRequest(request, env);
    } catch (error) {
      return handleError(error);
    }
  }
};
```

## Cloudflare Features Usage

### 1. KV Storage Patterns
```typescript
// Atomic operations with KV
async function updateVMState(
  vmId: string,
  env: Env,
  update: (state: VMState) => VMState
): Promise<VMState> {
  // Use transaction pattern for atomic updates
  for (let i = 0; i < 3; i++) {
    const currentState = await env.VM_STATUS.get(vmId, 'json');
    const newState = update(currentState);
    
    // Try to update with condition
    const success = await env.VM_STATUS.put(
      vmId,
      JSON.stringify(newState),
      {
        // Only update if value hasn't changed
        conditions: { keyExists: true }
      }
    );
    
    if (success) return newState;
  }
  throw new Error('Failed to update VM state atomically');
}
```

### 2. Durable Objects for State
```typescript
export class VMStateManager implements DurableObject {
  constructor(private state: DurableObjectState) {}

  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url);
    const vmId = url.pathname.split('/').pop()!;

    switch (request.method) {
      case 'POST': {
        // Atomic state updates
        const currentState = await this.state.storage.get('state');
        const newState = computeNewState(currentState, request);
        await this.state.storage.put('state', newState);
        return new Response(JSON.stringify(newState));
      }
      
      case 'GET': {
        // Real-time state access
        const state = await this.state.storage.get('state');
        return new Response(JSON.stringify(state));
      }
    }
  }
}
```

### 3. R2 for Asset Storage
```typescript
async function handleVMLogs(
  vmId: string,
  logData: string,
  env: Env
): Promise<void> {
  const key = `vm-logs/${vmId}/${Date.now()}.log`;
  await env.VM_LOGS.put(key, logData, {
    customMetadata: {
      vmId,
      timestamp: new Date().toISOString()
    }
  });
}
```

## Worker-Specific Error Handling

### 1. Custom Error Types
```typescript
class VMOperationError extends Error {
  constructor(
    message: string,
    public vmId: string,
    public operation: 'start' | 'stop' | 'restart'
  ) {
    super(`VM ${operation} failed: ${message}`);
    this.name = 'VMOperationError';
  }
}

class ProxyError extends Error {
  constructor(
    message: string,
    public targetUrl: string,
    public statusCode: number
  ) {
    super(`Proxy request failed: ${message}`);
    this.name = 'ProxyError';
  }
}
```

### 2. Error Response Formatting
```typescript
function handleWorkerError(error: Error): Response {
  // Log error with worker-specific context
  console.error('Worker Error:', {
    name: error.name,
    message: error.message,
    stack: error.stack,
    timestamp: new Date().toISOString()
  });

  if (error instanceof VMOperationError) {
    return new Response(
      JSON.stringify({
        error: 'VM Operation Failed',
        vmId: error.vmId,
        operation: error.operation,
        message: error.message
      }),
      { status: 500 }
    );
  }

  if (error instanceof ProxyError) {
    return new Response(
      JSON.stringify({
        error: 'Proxy Request Failed',
        target: error.targetUrl,
        status: error.statusCode,
        message: error.message
      }),
      { status: error.statusCode }
    );
  }

  return new Response(
    JSON.stringify({
      error: 'Internal Worker Error',
      message: error.message
    }),
    { status: 500 }
  );
}
```

## Worker-Specific Testing

### 1. Miniflare Setup
```typescript
import { createMiniflare } from 'miniflare';

describe('VM Management Worker', () => {
  let mf: Miniflare;

  beforeAll(async () => {
    mf = createMiniflare({
      modules: true,
      script: `
        export default {
          async fetch(request, env) {
            // Worker code
          }
        }
      `,
      kvNamespaces: ['VM_STATUS'],
      durableObjects: { VM_STATE: 'VMStateManager' }
    });
  });

  it('should handle VM operations', async () => {
    const response = await mf.dispatchFetch('http://localhost/api/v1/vms/start', {
      method: 'POST',
      body: JSON.stringify({ vmId: 'test-vm' })
    });

    expect(response.status).toBe(200);
  });
});
```

### 2. Mocking Worker Environment
```typescript
function createMockEnv() {
  return {
    VM_STATUS: {
      get: jest.fn(),
      put: jest.fn(),
      delete: jest.fn()
    },
    VM_LOGS: {
      put: jest.fn(),
      get: jest.fn()
    },
    VM_STATE: {
      get: jest.fn(),
      idFromName: jest.fn()
    }
  };
}

describe('VM Operations', () => {
  const env = createMockEnv();

  it('should start VM', async () => {
    env.VM_STATUS.get.mockResolvedValue(JSON.stringify({ status: 'stopped' }));
    
    const response = await worker.fetch(
      new Request('http://localhost/api/v1/vms/test-vm/start', {
        method: 'POST'
      }),
      env
    );

    expect(response.status).toBe(200);
    expect(env.VM_STATUS.put).toHaveBeenCalledWith(
      'test-vm',
      expect.stringContaining('"status":"starting"')
    );
  });
});
```


